<html>

	<head>

		<title>
			ShaderMate: Honey, does this shader make my butt look big?
		</title>

		<style>

			/*body { margin: 0; width: 100%; height: 100%; }*/
			/*canvas { width: 100%; height: 100%; }*/

		</style>

		<script src="js/jquery-latest.js"></script>
		<script src="js/jquery-ui-latest.js"></script>
		<script src="js/jquery.layout-latest.js"></script>
		<!-- <script src="js/jquery.ui.all.js"></script> -->
		<script>
			var bodyLayout;
			$(document).ready(function () {
				bodyLayout = $('body').layout({ 
					applyDefaultStyles: true,
					// livePaneResizing: true,
					east__size: 0.5,
					east__slidable: false,
					east__resizable: true,
					east__animatePaneSizing: true,
					east__allowOverflow: true,
					east__spacing_open: 	10,
					east__spacing_closed: 	10,
					east__fxSpeed_size: "fast",
					onresize_end: resize
					// east__onresize: function () {
					// 	console.log(
					// 		$("#ui-center").width(),
					// 		$("#ui-center").height()
					// 	);
					// },
					// east__fxSpeed_open: 1000,
				});
				resize();
			});
		</script>

	</head>

	<body>


		<div id="ui-center" class="ui-layout-center"></div>
		<!-- <div class="ui-layout-north">North</div> -->
		<!-- <div class="ui-layout-south">South</div> -->
		<!-- <div class="ui-layout-east">East</div> -->
		<!-- <div class="ui-layout-west">West</div> -->

		<div class="ui-layout-east" style="padding: 0;">

		<!-- <div style="padding:5px; margin:2px;">Mesh Fragment Shader</div> -->

			<textarea id="code" name="code" style="display: none;">
varying vec3 vNormal;
varying float vDepth;

void main() 
{
	vec3 l = normalize(vec3(1.0));
	vec3 nNormal = normalize(vNormal);
	float NDotL = dot(nNormal, l);
	// comment
	vec3 outCol = vec3(0.5+0.5*nNormal);
	gl_FragColor = vec4(outCol, 1.0);
}
</textarea>

		</div>

		<script src="js/three.js"></script>
		<script src="js/stats.min.js"></script>

		<script src="lib/codemirror.js"></script>
		<link rel="stylesheet" href="lib/codemirror.css">
		<link rel="stylesheet" href="theme/dracula.css">
		<script src="mode/glsl/glsl.js"></script>
		<style type="text/css">
			.CodeMirror 
			{
				height: auto;
			}
			.ui-layout-pane
			{
				padding:0 !important;
				border:0 !important;
				overflow:hidden !important;
			}
		</style>

		<script type="text/javascript">
			
			var editor = CodeMirror.fromTextArea(
				// element
				document.getElementById("code"),
				// options
				{
					mode: "text/x-glsl",
					lineNumbers: true,
					viewportMargin: Infinity,
					theme: "dracula",
					lineWrapping: true,
					extraKeys: {
						"Ctrl-R": function () {
							alert("run");
						},
						"Cmd-R": function () {
							alert("run");
						},
						"Ctrl-S": function () {
							alert("save");
						},
						"Cmd-S": function () {
							alert("save");
						},
					}
				}
			);

		</script>

		<script type="text/javascript">
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer({antialias:false});
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor(0x282A36)
			$("#ui-center").append( renderer.domElement );

			var geometry = new THREE.TorusKnotGeometry( 1 , 0.3 , 64 , 32 );
			// var geometry = new THREE.SphereGeometry( 1 , 12, 12 );
			// var geometry = new THREE.BoxGeometry( 1,1,1 );

			var dLight = new THREE.DirectionalLight( 0xFFFFFF , 0.5 );
			dLight.position.set(1,1,1);
			scene.add(dLight);

			var aLight = new THREE.AmbientLight( 0x7F7F7F );
			scene.add(aLight);

			vertexShader = [
				'precision mediump float;',
				'varying vec3 vNormal;',
				'varying float vDepth;',
				'void main() ',
				'{',
					'vNormal = (modelMatrix * vec4(normal, 0.0)).xyz;',
					'vec4 pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
					// 'vDepth = (2.0 * pos.z - 0.1 - 1000.0) / (1000.0 - 0.1) / pos.w;',
					'float zFar = 1000.0;',
					'float zNear = 0.1;',
					'vDepth = 2.0*zFar*zNear / (zFar + zNear - (zFar - zNear)*(2.0*pos.z - 1.0));',
					// 'vDepth = pos.z;',
					'gl_Position = pos;',
				'}',
			].join('\n');

			var testFragmentShader = [

				// 'precision mediump float;',

				// from vert shader
				'varying vec3 vNormal;',
				'varying float vDepth;',
				
				'void main() ',
				'{',
					'vec3 nNormal = normalize(vNormal);',
					'float NDotL = 0.0;',
					// 'for (int i = 0; i < NUM_DIR_LIGHTS; i++)',
						// 'NDotL += dot(nNormal, directionalLightDirection[i]);',
						// 'NDotL += 0.2;',
					'vec3 outCol = vec3(0.5+0.5*nNormal);',
					'gl_FragColor = vec4(outCol, 1.0);',
				'}'

			].join('\n');

			var material = new THREE.ShaderMaterial( {
				vertexShader: vertexShader,
				fragmentShader: testFragmentShader,
				shading: THREE.SmoothShading
			} );

			material.needsUpdate = true;

			var mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );
			camera.position.z = 5;

			var stats = new Stats();
			stats.setMode( 0 );
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';
			$("#ui-center").append( stats.domElement );

			animate();
			function animate () {

				mesh.rotation.x += 0.005;
				mesh.rotation.y += 0.005;

				requestAnimationFrame(animate);
				render();
			}
			function render()
			{
				renderer.render(scene, camera);

				stats.update();
			}

			function resize() {
				var w = $("#ui-center").width();
				var h = $("#ui-center").height();
				// console.log(w, h);
				renderer.setSize( w , h );
				camera.aspect = w / h;
				camera.updateProjectionMatrix();
			};
			// window.addEventListener( 'resize', resize, false );
			resize();
			// bodyLayout.option["center"].onresize = resize();

			function updateShader() {

				// mesh.material = new THREE.ShaderMaterial( {

				// 	vertexShader: vertexShader,
				// 	fragmentShader: $("#code").val(),
				// 	shading: THREE.SmoothShading
				// } );
			}

			// editor.on("change", function() {
			// 	console.log(editor.getValue());
			// });
			
			// editor.on("change", function(arg0, arg1) {
			// 	// console.log(editor.getValue());
			// 	console.log(arg1);
			// });
			
			// editor.on("keyHandled", function(cm, name, event) {
			// 	// console.log(editor.getValue());
			// 	console.log(name);
			// });
		</script>

	</body>

</html>